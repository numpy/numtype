{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"NumType documentation","text":"<p>NumType provides experimental typing stubs for NumPy.</p> <ul> <li> <p> User guide</p> <p>The user guide provides in-depth information on the key concepts of NumType with useful background information and explanation.</p> <p> To the user guide</p> </li> <li> <p> API reference</p> <p>The reference guide contains a detailed description of the functions, modules, and objects included in NumType.</p> <p> To the reference guide</p> </li> <li> <p> Contributor's guide</p> <p>Want to add to the codebase? The contributing guidelines will guide you through the process of improving NumType.</p> <p> To the contributor's guide</p> </li> </ul>"},{"location":"reference/","title":"NumType reference","text":"<p>coming soon</p>"},{"location":"dev/","title":"Contributing to NumType","text":""},{"location":"dev/#setting-up-the-environment","title":"Setting up the environment","text":"<p>Ensure you have <code>uv</code> installed. Now you can install the project with the dev dependencies:</p> <pre><code>uv sync\n</code></pre> <p>You can also install it with a specific Python version, e.g. <code>3.11</code>, as</p> <pre><code>uv sync --python 3.11\n</code></pre>"},{"location":"dev/#linting-and-formatting-with-ruff","title":"Linting and formatting with <code>ruff</code>","text":"<p>NumType uses <code>ruff</code> for linting and formatting, and is automatically installed as a local development dependency. This way, you can lint all <code>.py</code> and <code>.pyi</code> files with:</p> <pre><code>$ uv run ruff check\nAll checks passed!\n</code></pre> <p>Or, to format your code, run</p> <pre><code>$ uv run ruff format\n351 files left unchanged\n</code></pre> <p>Be sure to do this before you open a pull request \u2014 the CI will complain if you don't.</p> <p>For more details, see https://docs.astral.sh/ruff/.</p>"},{"location":"dev/#type-checking-and-testing","title":"Type-checking and Testing","text":"<p>To validate that the annotations are correct and run tests, we use several tools: basedpyright, mypy, and pytest. All are included as development dependency-group, so that <code>uv sync</code> will install them by default.</p>"},{"location":"dev/#basedpyright","title":"basedpyright","text":"<p>You can run basedpyright on the entire project using:</p> <pre><code>$ uv run basedpyright\n0 errors, 0 warnings, 0 notes\n</code></pre> <p>Since this can take somewhere between 20 to 50 seconds to run, you may want to limit this to a subdirectory or a specific file that you're working on.</p> <p>See https://docs.basedpyright.com/ for IDE integration and other info.</p>"},{"location":"dev/#mypy","title":"mypy","text":"<p>Mypy is used for type-checking the codebase and the type-tests.</p> <p>General Type Checking</p> <p>To run mypy generally (excluding the main numpy dependency group):</p> <pre><code>uv run --no-editable --no-group=numpy mypy .\n</code></pre> <p>Cache Issues</p> <p>In rare cases, the cache (<code>.mypy_cache</code> in the <code>numtype</code> root) can get corrupted, leading to incorrect results. If CI output differs from your local output, delete this directory.</p> <p>The documentation can be found at https://mypy.readthedocs.io/, and issues can be reported at python/mypy.</p>"},{"location":"dev/#pytest","title":"pytest","text":"<p>Pytest runs runtime tests located in <code>src/*/@test</code>. It works out-of-the-box:</p> <pre><code>uv run pytest [OPTIONS]\n</code></pre> <p>For available options, see the pytest documentation.</p>"},{"location":"dev/#lefthook","title":"Lefthook","text":"<p>Lefthook is a modern Git hooks manager, which automatically lints and formats your code before you committing it. It will also keep your <code>uv</code> environment up-to-date with the lockfile when you <code>git pull</code>.</p> <p>To install it as a <code>uv</code> tool, run</p> <pre><code>uv tool install lefthook --upgrade\n</code></pre> <p>To set it up, navigate to the root of the <code>numtype</code> repo, and run</p> <pre><code>lefthook install\n</code></pre> <p>or</p> <pre><code>uvx lefthook install\n</code></pre> <p>Now let's see it all works:</p> <pre><code>$ lefthook validate\nAll good\n</code></pre> <p>See https://lefthook.dev/ for more information.</p>"},{"location":"dev/#tox","title":"Tox","text":"<p>You can run the linters, type-checkers, runtime tests, and <code>stubtest</code>, all at once through a single tox command.</p> <p>It's easiest to install it as a <code>uv</code> tool:</p> <pre><code>uv tool install tox --with tox-uv --upgrade\n</code></pre> <p>To run it, navigate to the root of the cloned <code>numtype</code> directory, and run</p> <pre><code>tox p\n</code></pre> <p>or alternatively,</p> <pre><code>uvx tox p\n</code></pre> <p>If all is good, then you should see something like this appear:</p> <pre><code>ruff: OK \u2714 in 0.05 seconds\npytest: OK \u2714 in 0.34 seconds\n3.11: OK \u2714 in 20.44 seconds\n3.12: OK \u2714 in 22.32 seconds\n3.13: OK \u2714 in 26.41 seconds\nbasedpyright: OK \u2714 in 27.33 seconds\n  ruff: OK (0.05=setup[0.03]+cmd[0.01,0.01] seconds)\n  pytest: OK (0.34=setup[0.02]+cmd[0.32] seconds)\n  basedpyright: OK (27.33=setup[0.02]+cmd[27.31] seconds)\n  mypy: OK (36.39=setup[0.02]+cmd[36.37] seconds)\n  3.11: OK (20.44=setup[0.42]+cmd[20.01] seconds)\n  3.12: OK (22.32=setup[0.44]+cmd[21.88] seconds)\n  3.13: OK (26.41=setup[0.48]+cmd[25.93] seconds)\n  congratulations :) (36.44 seconds)\n</code></pre> <p>Tox installs everything in isolated environments, so you don't have to worry about your local or global <code>pip</code> or <code>uv</code> environments.</p> <p>See https://tox.wiki/en/stable/ for more information.</p>"},{"location":"dev/#documentation","title":"Documentation","text":"<p>The documentation lives in <code>docs/</code>, the <code>README.md</code>, and <code>CONTRIBUTING.md</code>. Please read it carefully before proposing any changes. Ensure that the markdown is formatted correctly with dprint.</p>"},{"location":"dev/#previewing-documentation-site","title":"Previewing Documentation Site","text":"<p>NumType uses MkDocs for documentation static site generation. To preview the documentation site locally:</p> <pre><code>uv run mkdocs serve\n</code></pre> <p>This will start a local server at http://127.0.0.1:8000/numtype/ where you can preview your changes. The server automatically refreshes when you make changes to the documentation files.</p>"},{"location":"dev/#development-tools","title":"Development Tools","text":"<p>NumType provides several development tools to help with development.</p> <p>For detailed usage of each tool, please refer to the <code>README.md</code> in the <code>tool</code> directory or the docstrings within each tool.</p>"},{"location":"dev/#commit-message-style","title":"Commit message style","text":"<p>For the most part, commit messages in NumType should follow NumPy's guidelines for writing commit messages. The main difference is that we don't use the prefix acronyms (e.g. <code>TYP</code>). Instead, we use Gitmoji as a modern alternative. Using it gitmoji is not a hard requirement, just a colorful recommendation. For VSCode users it's most convenient to use the <code>gitmoji-vscode</code> extension.</p>"},{"location":"dev/#code-style","title":"Code style","text":"<p>For <code>.py</code> files, NumType follows the <code>black</code> style, and the <code>.pyi</code> stubs follow the official style guide for stubs in most cases. Both <code>.py</code> and <code>.pyi</code> are linted and formatted using <code>ruff</code>, which is one of the development dependencies.</p> <p>See the NumType style guide for more.</p>"},{"location":"dev/style/","title":"Style Guide","text":""},{"location":"dev/style/#typevar-names","title":"<code>TypeVar</code> names","text":"<p>Use <code>_{}T</code> for invariant <code>TypeVar</code> names, where <code>{}</code> is a concise human-readable description of the upper bound. Use a <code>*_co</code> or <code>*_contra</code> suffix to indicate co- or contra-variance.</p> Yes \u00a0  No \u00a0  <code>_T_co</code> <code>T_co</code> <code>_ScalarT</code> <code>_SCT</code> <code>_DTypeT</code> <code>_DType</code>"},{"location":"dev/style/#protocol-names","title":"Protocol names","text":"<p>Use <code>Can{}</code> for <code>Protocol</code> types with a single method, where <code>{}</code> is the CamelCase name of that method. This naming convention was originally introduced by jorenham/optype, and has been gaining popularity since. Note that this deviates from <code>Supports{}</code> from Python style guide for stubs, which is arguably more verbose and less descriptive.</p> <p>In line with both <code>optype</code> and the stub style guide, NumType also uses <code>Has{}</code> for single-attribute protocols, with <code>{}</code> the CamelCase attribute name.</p> Protocol member Yes \u00a0  No \u00a0  <code>__len__()</code> <code>CanLen</code> <code>Sized</code> <code>__fspath__()</code> <code>CanFSPath</code> <code>PathLike</code> <code>fileno()</code> <code>CanFileno</code> <code>HasFileno</code> <code>dtype</code> <code>HasDType</code> <code>DTypeLike</code>"},{"location":"dev/style/#newlines-between-overloaded-functions","title":"Newlines between overloaded functions","text":"<p>The ruff formatter tends to remove all whitespace between all functions. But for overloaded functions this is often bad for readability. To get around this, place a <code>\\n\\n#\\n</code> between first overload definition. For non-overloaded functions this should only be done to separate semantically different groups of functions. For an example, see <code>src/numpy-stubs/lib/_type_check_impl.pyi</code>:</p> <pre><code>@overload\ndef iscomplex(x: ToGeneric_0d) -&gt; np.bool: ...\n@overload\ndef iscomplex(x: ToGeneric_1nd) -&gt; Array[np.bool]: ...\n\n#\n@overload\ndef isreal(x: ToGeneric_0d) -&gt; np.bool: ...\n@overload\ndef isreal(x: ToGeneric_1nd) -&gt; Array[np.bool]: ...\n\n#\ndef iscomplexobj(x: _HasDType[Any] | ToGeneric_nd) -&gt; bool: ...\ndef isrealobj(x: _HasDType[Any] | ToGeneric_nd) -&gt; bool: ...\n</code></pre>"},{"location":"dev/style/#max-line-length","title":"Max line length","text":"<p>For <code>.py</code> files the lines must not exceed 88 characters in width, compatible with the black style.</p> <p>For <code>.pyi</code> stubs, a maximum line length of 120 characters applies. Note that this is different from the Python stub style guide, which recommends 130. There are several reasons for this choice:</p> <ul> <li>The github diff viewer supports at most 125 characters.</li> <li>In general, 120 is used far more often than 130 as character limit.</li> </ul>"},{"location":"user/","title":"NumType user guide","text":"<p>This guide is an overview and explains the important features; details are found in NumType reference.</p>"},{"location":"user/differences/","title":"Differences with NumPy","text":""},{"location":"user/differences/#concrete-scalar-types","title":"Concrete scalar types","text":"<p>Since NumPy 2.2, the <code>float64</code> and <code>complex128</code> scalar types were made into concrete types. Before that, they were aliases of <code>floating[_64Bit]</code> and <code>complexfloating[_64Bit, _64Bit]</code>, respectively. But at runtime, <code>floating</code> is not the same as <code>float64</code>, so this was incorrect.</p> <p>Before Numpy 2.2, type-checkers accepted the following assignment:</p> <pre><code>x: np.float64 = np.floating\n</code></pre> <p>But now that <code>float64</code> is a proper subclass of <code>floating</code>, this is no longer valid. Type-checkers will therefore report this as an error.</p> <p>However, many users did not like this, because it often required them to change a lot of their code. So for a smooth transition, we kept the other scalar types such as <code>int8</code> as aliases to <code>np.integer[_8Bit]</code> in NumPy. This is, in fact, one of the main reasons for why NumType was created.</p> <p>In NumType all scalar types are annotated as concrete subtypes, or aliases thereof. That means that <code>x: np.integer = int8</code> is not allowed in NumType, which in NumPy you could get away with.</p> <p>To be specific, the following scalar types are proper subclasses in NumType:</p> <ul> <li><code>int8</code>, <code>int16</code>, <code>int32</code>, and <code>int64</code></li> <li><code>uint8</code>, <code>uint16</code>, <code>uint32</code>, and <code>uint64</code></li> <li><code>float16</code>, <code>float32</code>, <code>float64</code>, and <code>longdouble</code></li> <li><code>complex64</code>, <code>complex128</code>, and <code>clongdouble</code></li> </ul> <p>The other numeric scalar types are defined as aliases, and assume a 64-bit platform.</p>"},{"location":"user/differences/#no-more-nbitbase","title":"No more <code>NBitBase</code>","text":"<p>The purpose of <code>numpy.typing.NBitBase</code> was as upper bound to a type parameter, for use in generic abstract scalar types like <code>floating[T]</code>. But the now concrete scalar types will no longer accept any <code>floating[T]</code>. <code>NBitBase</code> should therefore not be used anymore.</p>"},{"location":"user/differences/#alternatives","title":"Alternatives","text":"<p>Type parameters can instead use an abstract scalar type as an upper bound. So instead of</p> Python 3.11 and abovePython 3.12 and above <pre><code>import numpy as np\nimport numpy.typing as npt\nfrom typing import TypeVar\n\nNT = TypeVar(\"NT\", bound=npt.NBitBase)\n\ndef f(x: np.floating[NT]) -&gt; np.floating[NT]: ...\n</code></pre> <pre><code>import numpy as np\nimport numpy.typing as npt\n\ndef f[NT: npt.NBitBase](x: np.floating[NT]) -&gt; np.floating[NT]: ...\n</code></pre> <p>you can write</p> Python 3.11 and abovePython 3.12 and above <pre><code>import numpy as np\nfrom typing import TypeVar\n\nFloatT = TypeVar(\"FloatT\", bound=np.floating)\n\ndef f(x: FloatT) -&gt; FloatT: ...\n</code></pre> <pre><code>import numpy as np\n\ndef f[FloatT: np.floating](x: FloatT) -&gt; FloatT: ...\n</code></pre> <p>As you can see, this also makes the code more readable.</p> <p>But what if that isn't possible? For instance, you might have the following function:</p> Python 3.11 and abovePython 3.12 and above <pre><code>import numpy as np\nimport numpy.typing as npt\nfrom typing import TypeVar\n\nNT = TypeVar(\"NT\", bound=npt.NBitBase)\n\ndef f(x: np.complexfloating[NT]) -&gt; np.floating[NT]: ...\n</code></pre> <pre><code>import numpy as np\nimport numpy.typing as npt\n\ndef f[NT: npt.NBitBase](x: np.complexfloating[NT]) -&gt; np.floating[NT]: ...\n</code></pre> <p>In that case, you can rewrite it by using <code>typing.overload</code>:</p> <pre><code>import numpy as np\nfrom typing import overload\n\n@overload\ndef f(x: np.complex64) -&gt; np.float32: ...\n@overload\ndef f(x: np.complex128) -&gt; np.float64: ...\n@overload\ndef f(x: np.clongdouble) -&gt; np.longdouble: ...\n</code></pre> <p>And even though it has gotten more verbose, it requires less mental to interpret.</p>"},{"location":"user/differences/#extended-precision-removals","title":"Extended precision removals","text":"<p>The following non-existent scalar types have been removed (#209):</p> <ul> <li><code>int128</code> and <code>int256</code></li> <li><code>uint128</code> and <code>uint256</code></li> <li><code>float80</code> and <code>float256</code></li> <li><code>complex160</code> and <code>complex512</code></li> </ul> <p>These types will not be defined on any supported platform.</p>"},{"location":"user/differences/#aliases-of-clongdouble","title":"Aliases of <code>[c]longdouble</code>","text":"<p>The platform-dependent <code>float96</code> and <code>float128</code> types are equivalent aliases of <code>longdouble</code> (#397):, and their complex analogues, <code>complex192</code> and <code>complex256</code>, alias <code>clongdouble</code> (#391). This was done in order to minimize the expected amount of \"but it works on my machine\".</p>"},{"location":"user/differences/#return-types-of-clongdoubleitem-and-tolist","title":"Return types of <code>[c]longdouble.item()</code> and <code>.tolist()</code>","text":"<p>In Numpy, <code>longdouble</code> and <code>clongdouble</code> aren't annotated as concrete subclasses of <code>[complex]floating</code>, but as aliases. A consequence of this is that their <code>item</code> and <code>tolist</code> methods had to return the same type as that of all other <code>floating</code> and <code>complexfloating</code> types, i.e. <code>float</code> and <code>complex</code>. But this is incorrect for <code>longdouble</code> and <code>clongdouble</code>:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; np.longdouble(1).item()\nnp.longdouble('1.0')\n&gt;&gt;&gt; np.clongdouble(1).item()\nnp.clongdouble('1+0j')\n</code></pre> <p>In NumType, the stubs correctly reflect this runtime behaviour.</p>"},{"location":"user/differences/#removed-number__floordiv__","title":"Removed <code>number.__floordiv__</code>","text":"<p>The abstract <code>numpy.number</code> type represents a scalar that's either integer, float, or complex. But the builtin \"floordiv\" operator, <code>//</code> is only supported for integer and floating scalars. Complex numpy scalars will raise an error. But in NumPy, type-checkers will allow you to write the following type-unsafe code:</p> <pre><code>import numpy as np\n\ndef half(a: np.number) -&gt; np.number:\n    return a // 2\n\nhalf(np.complex128(1j))  # accepted\n</code></pre> <p>In NumType's <code>numpy-stubs</code>, the <code>numpy.number.__[r]floordiv__</code> methods don't exist. This means that if you have <code>numtype</code> installed, your type-checker will report <code>a // 2</code> as an error.</p>"},{"location":"user/differences/#mypy-plugin","title":"Mypy plugin","text":"<p>NumType does not support the numpy mypy plugin. The reasons for this are explained in the NumPy 2.3.0 deprecation notes.</p>"}]}